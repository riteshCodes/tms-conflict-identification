"""
This module is for calculating the minimum headways
Only the function generate_minimum_headways is meant for use outside of this file
"""
import itertools
from dataclasses import dataclass
from itertools import permutations
from os import path
from pathlib import Path
from re import split
from xml.etree import ElementTree as ET

import library.utils
import library.writer
from library.parser import get_all_verlauf_nodes

import modules.occupancy_times
from occupancy_times import read_occupancy_times
from train_pairs import get_relevant_train_pairs

dict_of_minimum_headways = {}


@dataclass
class Times:
    """
    The relevant occupancy times on one part of the track
    """
    id: str
    vorbelegungszeit: float
    fahrzeit: float
    nachbelegungszeit: float


def get_times(block: ET.ElementTree, cutoff: int = None) -> list:
    """
    Create a list of Times objects for all relevant parts in the block

    :param cutoff: The number of the last zugschlussstelle to consider
    :param block:
    :return:
    """
    block_id = block.attrib['id']
    vorbelegungszeit = float(block.find('vorbelegungszeit').text)
    fahrzeit = sum(map(float, block.find('driving_time').text.split(" ")[0:cutoff]))
    nachbelegungszeit = float(block.find('nachbelegungszeit').text.split(" ")[-1 if cutoff is None else cutoff - 1])
    return Times(block_id, vorbelegungszeit, fahrzeit, nachbelegungszeit)


def is_einfahrsignal(element: object, verlauf: list, direction: str) -> bool:
    """
    Check whether the element is the entrysignal(Einfahrsignal) to a node (Fahrstraßenknoten)

    :param element: The element in question (as parsed from the verlauf)
    :param verlauf: The verlauf of the train (as parsed in get_all_verlauf_nodes)
    :param direction: The direction that the train is travelling in (Either "F" or "S")
    :return: True if it is a entrysignal, False in all other cases
    """
    signalart = element.find('Signalart')
    if signalart is not None:
        if signalart.text == "Standort Einfahrsignal":
            return True
        if signalart.text == "Blocksignal":
            return False
    now_checking = False
    switch_in_front = False
    switch_behind = False
    for link in verlauf:
        for current_element in link:
            if "Hauptsignal" in current_element.tag and current_element.find("ID").text == element.find("ID").text:
                if switch_in_front:
                    return False
                now_checking = True

            if now_checking:
                if "Hauptsignal" in current_element.tag and not switch_behind:
                    return False
                if "Weiche" in current_element.tag:
                    switch_behind = True
                if "Halteplatz" in current_element.tag and not switch_in_front:
                    return True
            else:
                if "Weiche" in current_element.tag:
                    switch_in_front = True
                elif "Hauptsignal" in current_element.tag and library.utils.direction_of_node(
                        current_element) == direction:
                    switch_in_front = False
    return False


def is_ausfahrsignal(element: object, verlauf: list, direction: str) -> bool:
    """
    Check whether the element is the exitsignal (Ausfahrsignal) to a node (Fahrstraßenknoten)

    :param element: The element in question (as parsed from the verlauf)
    :param verlauf: The verlauf of the train (as parsed in get_all_verlauf_nodes)
    :param direction: The direction that the train is travelling in (Either "F" or "S")
    :return: True if it is a exitsignal, False in all other cases
    """
    signalart = element.find('Signalart')
    if signalart is not None:
        if signalart.text == "Standort Ausfahrsignal":
            return True
        if signalart.text == "Blocksignal":
            return False
    next_signal = False
    for link in verlauf:
        for current_element in link:
            if "Halteplatz" in current_element.tag and library.utils.direction_of_node(current_element) == direction:
                next_signal = True
            if "Hauptsignal" in current_element.tag and next_signal:
                next_signal = False
                if current_element.find("ID").text == element.find("ID").text:
                    return True
    return False


def block_sections_on_mainline(occupancy_times: ET.ElementTree, verlauf: list[ET.ElementTree]) -> list[list[Times]]:
    """
    generates sections of blocks between nodes

    :param occupancy_times: all the blocks (output of the occupancy times module)
    :param verlauf: list containing the verlauf from every link (output from get_all_verlauf_nodes)
    :return: list of every section between the exit from a node and the entry of another
    (The sections are lists of blocks as generated by the occupancy times module)
    """
    list_of_sections = []
    times_in_section = []
    ongoing_section = False
    get_last_parts = False
    for link in occupancy_times:
        for block in link:
            signal_ids = block.attrib['id'].split('-')
            direction = library.utils.direction_of_node(library.utils.find_node_by_id(signal_ids[0]))
            if get_last_parts:
                cutoff = 1
                last_block_until = {}
                for fahrstrassenabschnitt in block.find("block_info").findall('fahrstrassenabschnitt'):
                    times = get_times(block, cutoff)
                    last_block_until[fahrstrassenabschnitt.find("end_abschnitt_id").text] = times
                    cutoff += 1
                list_of_sections.append(
                    (times_in_section, last_block_until))  # add the list of times in section to list of sections
                get_last_parts = False  # reset
                times_in_section = []  # empty list1
            elif not ongoing_section and is_ausfahrsignal(
                    library.utils.find_node_by_id(signal_ids[0]), verlauf,
                    direction):  # startsignal of block is exitsignal of knoten
                ongoing_section = True  # start section
            elif ongoing_section and is_einfahrsignal(
                    library.utils.find_node_by_id(signal_ids[1]), verlauf,
                    direction):  # endsignal of block is einfahrsignal of knoten
                ongoing_section = False  # stop section
                times_in_section.append(get_times(block))  # add block to list1
                get_last_parts = True
            elif ongoing_section:
                times_in_section.append(get_times(block))  # add block to list1
    return list_of_sections


def add_shared_sections(train_pair: tuple):
    """
    Adds the minimum headway times of this train pair to the dictionary dict_of_minimum_headways

    :param train_pair: pair of trains (e.x.: ("S1 1111", "S1 1113"))
    """
    occupancy_times_i = read_occupancy_times(train_pair[0])
    verlauf_i = get_all_verlauf_nodes(split(" ", train_pair[0])[0], split(" ", train_pair[0])[1])
    train_i = block_sections_on_mainline(occupancy_times_i, verlauf_i)

    occupancy_times_j = read_occupancy_times(train_pair[1])
    verlauf_j = get_all_verlauf_nodes(split(" ", train_pair[1])[0], split(" ", train_pair[1])[1])
    train_j = block_sections_on_mainline(occupancy_times_j, verlauf_j)

    print("adding: " + str(train_pair))

    for (train_i_section_k, train_j_section_l) in itertools.product(train_i, train_j):
        times_of_train_i_section_k = train_i_section_k[0]
        times_of_train_j_section_l = train_j_section_l[0]
        if times_of_train_i_section_k[0].id == times_of_train_j_section_l[0].id:
            last_shared_zugschlussstelle = None
            for key_i, key_j in zip(train_i_section_k[1].keys(), train_j_section_l[1].keys()):
                if key_i == key_j:
                    last_shared_zugschlussstelle = key_i
            times_of_train_i_section_k.append(train_i_section_k[1][last_shared_zugschlussstelle])
            times_of_train_j_section_l.append(train_j_section_l[1][last_shared_zugschlussstelle])

            section_name = times_of_train_i_section_k[0].id.split("-")[0]
            try:
                dict_of_minimum_headways[section_name][train_pair] = \
                    calculate_minimum_headway(times_of_train_i_section_k, times_of_train_j_section_l)
            except KeyError:
                dict_of_minimum_headways[section_name] = {}
                dict_of_minimum_headways[section_name][train_pair] = \
                    calculate_minimum_headway(times_of_train_i_section_k, times_of_train_j_section_l)


def calculate_minimum_headway(section_train_i: list[Times], section_train_j: list[Times]) -> float:
    """
    calculates the minimum headway between train i and train j on the same section
    (with train i going through the section first)

    :param section_train_i: list of occupancy times on blocks on this section for train1
    :param section_train_j: list of occupancy times on blocks on this section for train2
    :return: the minimum headway in minutes
    """
    z_max = 0
    n = len(section_train_i)
    for m in range(0, n):
        z = section_train_i[0].vorbelegungszeit  # vorbelegungszeit train 1 block 1
        for k in range(0, m + 1):
            z += section_train_i[k].fahrzeit  # fahrzeit train 1 block k
        z += section_train_i[m].nachbelegungszeit  # nachbelegungszeit train 1 block m
        z += section_train_j[m].vorbelegungszeit  # vorbelegungszeit train 2 block m
        for k in range(0, m):
            z -= section_train_j[k].fahrzeit  # fahrzeit train 2 block k
        z -= section_train_j[0].vorbelegungszeit  # vorbelegungszeit train 2 block 1
        z_max = max(z, z_max)
    return z_max


def generate_minimum_headways(train_pair: tuple = None) -> dict:
    """
    Calls the relevant functions for either generating all minimum headways and storing them in csv format
    or only for one train pair and returning the dictionary in either case (for one train only it doesn't update the csv)

    :param train_pair: empty -> all train pairs or the desired train pair like e.x.: ("S1 1111", "S1 1113") -> just this pair
    :return: a dictionary containing dictionaries for every section with the minimum headways on there
    """
    if train_pair is None:
        trains = modules.train_pairs.get_relevant_directories()
        for pair in permutations(trains, 2):
            add_shared_sections(pair)
    else:
        add_shared_sections(train_pair)
    return dict_of_minimum_headways


def write_minimum_headways() -> None:
    """
    Write the minimum headways for all train pairs to output/minimum_headways.xml

    :return: Nothing
    """
    generate_minimum_headways()

    minimum_headways = ET.Element("minimum_headways")
    package_dir = Path(__file__).parent.parent
    output_path = path.join(package_dir, Path('output/minimum_headways.xml'))
    for section_name, section_headways in dict_of_minimum_headways.items():
        section = ET.SubElement(minimum_headways, "Section", dict(ID_exitsignal=section_name))
        for pair, headway in section_headways.items():
            minimum_headway = ET.SubElement(section, "TrainPair")
            train_pair_name = ET.SubElement(minimum_headway, "Name")
            train_pair_name.text = str(pair[0]) + " - " + str(pair[1])
            value = ET.SubElement(minimum_headway, "Value")
            value.text = str(headway)
    library.writer.write_et(minimum_headways, output_path)


if __name__ == "__main__":
    # add_shared_sections(("RB20 2212", "IC100 3103"))
    write_minimum_headways()
    print(dict_of_minimum_headways)
